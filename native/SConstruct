#!/usr/bin/env python
import os
from SCons.Script import *


# This file has been generated by Gemini AI
# --------------------------------------------------------------
# CONFIGURATION
# --------------------------------------------------------------
module_name = "life_particles"
godot_cpp_path = "godot-cpp"

# Output directory for the final library (relative to the SConstruct file)
godot_bin_path = "../godot/bin" 

# Detect platform and target
platform = ARGUMENTS.get("platform", "linux") # Default to 'linux'
target = ARGUMENTS.get("target", "template_debug")

is_debug = target == "template_debug"

env = Environment()

# --------------------------------------------------------------
# CUDA SETUP
# --------------------------------------------------------------
# Default CUDA path based on the operating system
if platform == "windows":
    cuda_path_default = "C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v13.0"
else: # linux
    cuda_path_default = "/usr/local/cuda"

cuda_path = os.environ.get("CUDA_PATH", cuda_path_default) 
cuda_path_normalized = cuda_path.replace("\\", "/")
nvcc = f"{cuda_path_normalized}/bin/nvcc"
if platform == "windows":
    nvcc += ".exe"

cuda_include = f"{cuda_path_normalized}/include"

# print(f"Using NVCC at: {nvcc}") # Omitted print for cleaner output
# print(f"CUDA Path: {cuda_path_normalized}") # Omitted print for cleaner output

# --------------------------------------------------------------
# COMPILER SETUP (GCC/MSVC)
# --------------------------------------------------------------
if platform == "windows":
    # MSVC Configuration
    env["CC"] = "cl"
    env["CXX"] = "cl"
    env["LINK"] = "link"
    env.Append(CPPDEFINES=["_CRT_SECURE_NO_WARNINGS"])
    env.Append(CCFLAGS=["/std:c++17", "/FS"])

    if is_debug:
        env.Append(CCFLAGS=["/Zi", "/MT"])
        env.Append(LINKFLAGS=["/DEBUG"])
    else:
        env.Append(CCFLAGS=["/MT"])
        
elif platform == "linux":
    # GCC/G++ Configuration
    env["CC"] = "gcc"
    env["CXX"] = "g++"
    
    # Standard flags for creating shared libraries
    env.Append(CCFLAGS=["-std=c++17", "-fPIC"]) 
    
    if is_debug:
        env.Append(CCFLAGS=["-g"]) 
    else:
        env.Append(CCFLAGS=["-O3"])
        
    # Runtime Link Path (Crucial for finding libgodot-cpp.so at runtime)
    env.Append(LINKFLAGS=["-Wl,-rpath=$ORIGIN"]) 

# --------------------------------------------------------------
# Include paths
# --------------------------------------------------------------
env.Append(CPPPATH=[
    f"{godot_cpp_path}/gdextension",
    f"{godot_cpp_path}/include",
    f"{godot_cpp_path}/gen/include",
    cuda_include,
    ".",
    "include",
    "src",
])

# Godot-cpp built library (Input Library)
env.Append(LIBPATH=[f"{godot_cpp_path}/bin"])
env.Append(LIBS=[f"libgodot-cpp.{platform}.{target}.x86_64"])

# --------------------------------------------------------------
# CUDA BUILDER
# --------------------------------------------------------------
if platform == "windows":
    # Helper to get the 8.3 short path name
    def get_short_path(long_path):
        if " " not in long_path:
            return long_path
        import ctypes
        from ctypes import wintypes
        GetShortPathNameW = ctypes.windll.kernel32.GetShortPathNameW
        GetShortPathNameW.argtypes = [wintypes.LPCWSTR, wintypes.LPWSTR, wintypes.DWORD]
        GetShortPathNameW.restype = wintypes.DWORD

        buf = ctypes.create_unicode_buffer(300)
        GetShortPathNameW(long_path, buf, 300)
        return buf.value.replace("\\", "/")

    cuda_path_nvcc = get_short_path(cuda_path)
    # MSVC Host Compiler Flags passed to NVCC
    cuda_host_compiler_flags = [
        '-Xcompiler "/MT"',
        '-Xcompiler "/EHsc"',
        '-Xcompiler "/FS"',
        '-Xcompiler "/std:c++17"'
    ]

else: # Linux
    cuda_path_nvcc = cuda_path_normalized
    # GCC Host Compiler Flags passed to NVCC
    cuda_host_compiler_flags = [
        '-Xcompiler "-fPIC"', 
        '-Xcompiler "-std=c++17"'
    ]
    if is_debug:
        cuda_host_compiler_flags.append('-Xcompiler "-g"')

cuda_includes = [
    f"{cuda_path_nvcc}/include",
    "godot-cpp/gdextension",
    "godot-cpp/include",
    "godot-cpp/gen/include",
    "include",
    "src",
]

cuda_include_flags = " ".join([f'-I"{p}"' for p in cuda_includes])
cuda_host_flags = " ".join(cuda_host_compiler_flags)

cuda_builder = Builder(
    # NVCC Action: Compile the .cu file into an object file
    action=(
        f'"{nvcc}" --allow-unsupported-compiler '
        f'-c "${{SOURCE.abspath}}" -o "${{TARGET.abspath}}" '
        f'-std=c++17 -arch=sm_75 {cuda_include_flags} '
        f'{cuda_host_flags}'
    ),
    suffix=".obj",
    src_suffix=".cu"
)

env.Append(BUILDERS={"CudaObject": cuda_builder})

# Linker paths for CUDA runtime library
if platform == "windows":
    env.Append(LIBPATH=[f"{cuda_path_nvcc}/lib/x64"])
else: # linux
    # Common Linux paths for libraries
    env.Append(LIBPATH=[f"{cuda_path_nvcc}/lib64", f"{cuda_path_nvcc}/lib"]) 
    
env.Append(LIBS=["cudart"])

# --------------------------------------------------------------
# Sources
# --------------------------------------------------------------
cpp_sources = Glob("src/*.cpp")
cu_sources = Glob("src/*.cu")

# Build CUDA objects first
cuda_objects = [env.CudaObject(str(s)) for s in cu_sources]
all_sources = cpp_sources + cuda_objects

# --------------------------------------------------------------
# OUTPUT LIBRARY (Reverting to original successful target naming logic)
# --------------------------------------------------------------

# 1. Ensure the necessary SCons variables are set for the linker suffixes
# This is usually done by SCons when environment is initialized, but we use them explicitly.

# Define the final filename structure (e.g., life_particles.linux.template_debug.so)
library_name_base = f"{module_name}.{platform}.{target}"

# Construct the full target path and filename using the desired destination and SCons variables.
# This results in the path: ../godot/bin/liblife_particles.linux.template_debug.so (or .dll)
library_target = os.path.join(
    godot_bin_path, 
    f"{env.subst('$SHLIBPREFIX')}{library_name_base}{env.subst('$SHLIBSUFFIX')}"
)

# Create the final shared library
library = env.SharedLibrary(
    target=library_target,
    source=all_sources
)

# Note: We use the target variable above to specify the exact output path and name, 
# making the separate env.Install() call redundant and unnecessary.

Default(library)